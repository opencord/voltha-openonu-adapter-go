{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "14ed33cb_8bf0f695",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000666
      },
      "writtenOn": "2021-10-25T08:39:41Z",
      "side": 1,
      "message": "Maybe I don\u0027t understand the real intention, but this way it does not make much sense to me.\nSo if the intention was really to provide the \u0027failed\u0027 state if the enabling cannot be done correctly, then within the FSM some additional means must be implemented to detect (and collect) the error condition (instead of simply aborting) and that can be used in the end to generate an according event.\nPerhaps the implicit enumeration increment can be used for that similar to what was done for OmciAniConfigDone/OmciAniResourceRemoved (here UniEnableStateDone/UniEnableStateFailed) [UniEnableStateFailed used within the FSM as implicit +1 event]. But it does not make much sense to me to start the FSM with the Failed indication as request event.",
      "revId": "65851abfc7cd799f833226a53442b723377e7405",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "62814a32_66b6f73a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-10-25T13:42:39Z",
      "side": 1,
      "message": "There are several places where the enable fails and FSM is reseted but only one place where it succeeds(where all OMCI messages are successfully responded). So I chose to set the initial value of request event as UniEnableStateFailed and set it UniEnableStateDone when the last omci message responded, instead of setting the initial value Done and set it Failed in several places in the FSM. Not a problem to change if you insist. I thought this is a cleaner way to implement. Maybe I\u0027m missing something else here.\n\nFor your \"simply aborting\" term could you elaborate it a bit? \n\nBy the incrementing implicit enumeration mention, do you mean to call processUniEnableStateDoneEvent() function instead of defining new processUniEnableStateFailedEvent() function?",
      "parentUuid": "14ed33cb_8bf0f695",
      "revId": "65851abfc7cd799f833226a53442b723377e7405",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f034c4c_aa4eb513",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000666
      },
      "writtenOn": "2021-10-25T17:43:51Z",
      "side": 1,
      "message": "As stated, perhaps I did not fully understand, but: \nYou start the admin processing now with the request \u0027UniEnableStateFailed\". This is now what is delivered also in success case from \u0027enterAdminDoneState()\u0027. And moreover you insered in enterResettingState() another ProcStatusUpdate. Note, that this state is also reached in case of error-free execution. So in the good case two times \u0027UniEnableStateFailed\u0027 will be delivered - in my point of view.\n\nI\u0027d prefer to keep requesting the expected \u0027good\u0027 result, and deliver the error really only in error case. As stated, for that you must insert an internal flag that is to be set for the error case in case you want to keep the event notification collected in the resetting state (or you do it always on each error exit directly). \n\u0027Simpy aborting\u0027 meant to leave/abort the processing without any event notification.",
      "parentUuid": "62814a32_66b6f73a",
      "revId": "65851abfc7cd799f833226a53442b723377e7405",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c1a29abb_0fd706d3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-10-25T20:24:24Z",
      "side": 1,
      "message": "I set the request to \u0027UniEnableStateFailed\u0027 in start, but set it \u0027UniEnableStateDone\u0027 after unLock sent to all UNIs, which means all the OMCI requests are sent successfully. So it is not  the \u0027UniEnableStateFailed\u0027 delivered in success case. \nI put the ProcStatusUpdate() in enterResettingState() because in failure cases(e.g an omci message is failed) FSM enters in reseting state but does not send a status update to device_handler and I didn\u0027t see a transition to enterAdminDoneState() after resetting. \n\nI can change the implementation to keep the initial request as success and set it failed in failure cases, but I guess I still need to call ProcStatusUpdate() in enterResettingState() to ensure that the update is sent to device_handler or make a state transition to  adminDoneState.",
      "parentUuid": "7f034c4c_aa4eb513",
      "revId": "65851abfc7cd799f833226a53442b723377e7405",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f7a2117_be3a43de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000666
      },
      "writtenOn": "2021-10-26T06:33:35Z",
      "side": 1,
      "message": "Seems I have missed that fragment n previous version that sets the event to UniEnableStateDone again. Anyway this way around now is really my preferred approach.",
      "parentUuid": "c1a29abb_0fd706d3",
      "revId": "65851abfc7cd799f833226a53442b723377e7405",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    }
  ]
}