{
  "comments": [
    {
      "key": {
        "uuid": "08614e93_0fdc3fba",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 1000116
      },
      "writtenOn": "2020-06-17T15:36:46Z",
      "side": 1,
      "message": "is this a cResSource o cResource ?",
      "range": {
        "startLine": 76,
        "startChar": 1,
        "endLine": 77,
        "endChar": 37
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da501578_4fea5f05",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 1000671
      },
      "writtenOn": "2020-06-18T11:42:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "08614e93_0fdc3fba",
      "range": {
        "startLine": 76,
        "startChar": 1,
        "endLine": 77,
        "endChar": 37
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f32d70f4_ae1d48b9",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 321,
      "author": {
        "id": 1000116
      },
      "writtenOn": "2020-06-17T15:36:46Z",
      "side": 1,
      "message": "what happens if one of the two calls fails and the completion never happens ? do we hold the lock indefinitely ?\nalso I believe here you are never releasing the lock explicitly.\n\nthe indefinite wait applies also for the other elements added to the following lines.",
      "range": {
        "startLine": 316,
        "startChar": 0,
        "endLine": 321,
        "endChar": 27
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44de3816_b18f832d",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 321,
      "author": {
        "id": 1000671
      },
      "writtenOn": "2020-06-18T11:42:14Z",
      "side": 1,
      "message": "Going to comment out the WIP for VOL-3038 to give Michael a chance to incorporate review comment after his vacation.",
      "parentUuid": "f32d70f4_ae1d48b9",
      "range": {
        "startLine": 316,
        "startChar": 0,
        "endLine": 321,
        "endChar": 27
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a6b9c2b_b8a1d5c9",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 321,
      "author": {
        "id": 1000666
      },
      "writtenOn": "2020-06-30T15:27:22Z",
      "side": 1,
      "message": "The design by contract here is, that all of the \u0027waiter functions\u0027 always must return and may not run endlessly.\nNow - you are right, that might be difficult with ongoing implementation with respect to ETCD access and the needed routines for the OMCI transfer of the configuration. But as long as no real danger of stucking in these functions is visible I would leave the implementation that simple. Moreover the control for ensuring the return must then be within the \u0027waiter functions\u0027 itself, e.g. by some extra success channel/timeout wait selection and critical processing in a further background. As long as possible I would try to avoid that. \nMoreover then the next question would be, how to react on some timeout here, meaning the setting of the TP config can\u0027t be trusted (such could be part of a more sophisticated error treatment implemented later as already generally discussed).\nRelease of the lock is done in waitForTpCompletion() - as stated in the comment.\nSo I will activate the code within next releases again (and attention must be laid on forced return of the \u0027waiter functions\u0027 then).",
      "parentUuid": "44de3816_b18f832d",
      "range": {
        "startLine": 316,
        "startChar": 0,
        "endLine": 321,
        "endChar": 27
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9042eacf_35000b20",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 321,
      "author": {
        "id": 1000116
      },
      "writtenOn": "2020-07-07T08:37:49Z",
      "side": 1,
      "message": "I agree with keeping it simple, what worries me is keeping the lock forever when wg.Wait() never finishes. I\u0027m fine with a timeout in the next issue fo the Code, maybe put a TODO and track in jira.\nif the setting of the TP can\u0027t be trusted I\u0027d say that we need to delete the ONu and treat as a whole new one when a new ONUDiscIndication comes in, thoughts ?",
      "parentUuid": "2a6b9c2b_b8a1d5c9",
      "range": {
        "startLine": 316,
        "startChar": 0,
        "endLine": 321,
        "endChar": 27
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7b1372fb_0556aafc",
        "filename": "internal/pkg/onuadaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 321,
      "author": {
        "id": 1000666
      },
      "writtenOn": "2020-07-08T10:07:41Z",
      "side": 1,
      "message": "I would not propose to track it with some Jira or even //TODO.\nI could add further comments for the \u0027waiter functions\u0027 that they must be ensured to return in acceptable time, even though that is already implicitly indicated by the wg reference argument (having that argument it is more or less straight forward, that such a routine may not run endlessly - except for the routine that really waits for completion.\nIn case the \u0027waiter functions\u0027 are extended to include asynchronous method calls, at that time clearly the timeout supervision must be integrated. The proposal is to do that at that specific time (and then it is a must and should not be put off).\nA better solution would be a wait group implementation with some implicit timeout, but that is not available in Go (as far as I have searched).\n\nThe other comment refers to problems getting the TP from etcd? I don\u0027t fully understand the proposal: Does it refer to some automatic deletion of the ONU from the adapter (or perhaps an ONU reboot - I would not know how to \u0027delete\u0027 some ONU)? I would not know, how the problems are then resolved when the ONU pops up again. Or does it refer to some manual ONOS-based intervention by the operator, who could also try to clean up etcd related issues - but then the question is, how the operator gets to know about such problems.",
      "parentUuid": "9042eacf_35000b20",
      "range": {
        "startLine": 316,
        "startChar": 0,
        "endLine": 321,
        "endChar": 27
      },
      "revId": "13c7c7e004107236f22bf9883cf65548a36e81a3",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    }
  ]
}